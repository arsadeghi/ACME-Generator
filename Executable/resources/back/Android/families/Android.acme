import $AS_GLOBAL_PATH/families/PubSubFam.acme;

import $AS_GLOBAL_PATH/families/CallReturnFam.acme;

import $AS_GLOBAL_PATH/families/RepositoryFam.acme;

family Android extends PubSubFam, CallReturnFam, RepositoryFam with {
   // A set of intent filters
   property type IntentFilterSetT = set { string };

   // A set of permissions
   property type PermissionsSetT = set { string };

    // The state of an activity. What is the initial state? Created? That is to say that
    // all activities are created when they exist in a system.
    property type ActivityStateT = enum {Created, Started, Paused, Stopped, Destroyed};


    port type ExplicitIntentResponsePortT extends ResponsePortT;

    abstract port type IntentCarryingPortT = {
        // A string that specifies the generic action to perform (such as view or pick).
        // In the case of a broadcast intent, this is the action that took place and is being reported.
        // The action largely determines how the rest of the intent is structuredï¿½particularly what is
        // contained in the data and extras.
        // You can specify your own actions for use by intents within your app (or for use by other apps
        // to invoke components in your app), but you should usually use action constants defined by the
        // Intent class or other framework classes.
        property action : string;

        // The URI (a Uri object) that references the data to be acted on and/or the MIME type of that data.
        // The type of data supplied is generally dictated by the intent's action. For example, if the action
        // is ACTION_EDIT, the data should contain the URI of the document to edit.
        // When creating an intent, it's often important to specify the type of data (its MIME type) in addition
        // to its URI. For example, an activity that's able to display images probably won't be able to play an
        // audio file, even though the URI formats could be similar. So specifying the MIME type of your data
        // helps the Android system find the best component to receive your intent. However, the MIME type can
        // sometimes be inferred from the URIï¿½particularly when the data is a content: URI, which indicates
        // the data is located on the device and controlled by a ContentProvider, which makes the data MIME
        // type visible to the system.
        property data : string;

        // A string containing additional information about the kind of component that should handle the intent.
        // Any number of category descriptions can be placed in an intent, but most intents do not require a
        // category. Here are some common categories:
        property category : string;
    };
    port type ImplicitIntentBroadcastAnnouncerPortT extends IntentCarryingPortT, PublishPortT;

    port type ExplicitIntentCallPortT extends RequestPortT, IntentCarryingPortT with {
      // The name of the component to start.
      property componentReference : string;
      rule mustReferenceComponent = invariant hasValue(componentReference);
    };


    port type ImplicitIntentBroadcastReceivePortT extends SubscribePortT;
    // Ports for a content provider call/response. port type ContentProviderCallPortT extends RequestPortT;
    port type ContentProviderResponsePortT extends RepositoryPortT;
    port type ServiceResponsePortT extends ResponsePortT;
    // Ports for a service call/response. port type ServiceCallPortT extends RequestPortT;
    port type ContentProviderCallPortT extends DataAccessorPortT;
    port type ServiceCallPortT extends CallPortT;

    // All components in android may have a permission, should be from the set of permissions from the
    // application? This component type is then the root for all android component types.
    abstract component type ApplicationElement = {
       // Permission that other apps need to have to access this component
       // (permission labels need tobe unnique -- who manages the uniquness and how is
       // it qualified? Is there a permission manager? What happens if I declare an
       // "illegal" permission?
       property permission : string;

       // The class that is represented by this activity in the Android app.
       property class : string;
    };

    abstract component type IntentFilteringApplicationElementT extends ApplicationElement with {
      // The set of intent filters that this activity possesses
      property intentFilters : IntentFilterSetT;
      property exported : boolean << default : boolean = false;>>;
      
      // This captures the default behavior that implicit intents automatically force an Activity to be exported.
      rule exportedIfIntentFilters = heuristic exported <-> size(intentFilters) > 0;
    };

    // An Activity is an application component that provides a screen with which users can interact
    // in order to do something, such as dial the phone, take a photo, send an email, or view a map.
    // Each activity is given a window in which to draw its user interface. The window typically
    // fills the screen, but may be smaller than the screen and float on top of other windows.;
    component type ActivityComponentT extends IntentFilteringApplicationElementT with {
      // many of the activity properties come from http://developer.android.com/guide/topics/manifest/activity-element.html


      // The permission that clients must have to launch the activity or otherwise get it to respond to an intent. Interestingly,
      // this property is optional and may be inherited from the application
      property permission : string;
      // The state of this activity. This property should capture the activity lifecycle, but t's unclear whether or
      // not this is a property that we care about
      property state : ActivityStateT;




      // The activity must have a state
      rule activityStateValid = invariant hasValue(state);
    };

    // A Service is an application component that can perform long-running operations in the background
    // and does not provide a user interface. Another application component can start a service and it
    // will continue to run in the background even if the user switches to another application.
    // Additionally, a component can bind to a service to interact with it and even perform
    // interprocess communication (IPC). For example, a service might handle network transactions,
    // play music, perform file I/O, or interact with a content provider, all from the background.;
    component type ServiceComponentT extends IntentFilteringApplicationElementT with {
      // The permission that that an entity must have in order to launch the service or bind to it. Again, this is optional
      property permission : string;

    };


    component type SystemServiceComponentT extends ServiceComponentT;

    //Content providers manage access to a structured set of data. They encapsulate the data, and
    // provide mechanisms for defining data security. Content providers are the standard interface
    // that connects data in one process with code running in another process.;
    component type ContentProviderComponentT extends RepositoryCompT with {
      // The permission that clients must have to read or write the content provider's data. Again, this is optional
      property read-permission : string;
      property write-permission : string;
      property exported : boolean <<default                 = false;>>;
    };

    // A broadcast receiver is a component that listens for system broadcasts. For now it is distinct component.
    component type BroadcastReceiverComponentT extends IntentFilteringApplicationElementT with {
      // The permission that broadcasters must have to send a message to the broadcast receiver. Again, this is optional
      property permission : string;


    };
    role type ExplicitIntentCallRoleT extends CallerRoleT;
    role type ExplicitIntentResponseRoleT extends ResponderRoleT;
    role type ImplicitIntentBroadcastAnnounceRoleT extends PublisherRoleT;
    role type ImplicitIntentBroadcastReceiveRoleT extends SubscriberRoleT;
    role type ContentProviderRequestRoleT extends DataAccessorRoleT;
    role type ContentProviderResponseRoleT extends RepositoryRoleT;
    role type ServiceCallRoleT;
    role type ServiceResponseRoleT;

     // what are the semantics of this connector? Purely asynchronous?
    connector type IntentBusT extends EventBusConnT;

    // This connector models the call/return communication via intents. Specifically, it captures the runtime behavior found in
    // the startActivityForResult API.
    connector type IntentCallResponseConnectorT extends CallReturnConnT with {
        property pending : boolean << default : boolean = false; >>;
    };

    // this connector enables communication between a content provider and another component. A client application accesses the
    // data from a content provider with a ContentResolver object. The ContentResolver object provides query(), insert(), update(),
    // and delete() methods for accessing data from a content provider. This connector is similar to a ODBC connector for traditional
    // SQL databases.
    connector type ContentProviderConnectorT extends DataAccessConnT;

    // The recommended method of communication between Activities and Services for different applicationsÕ
    // Inter-Process Communication (IPC) is by using Messengers. A message handler is basically a callback function that
    // asynchronously receives data. It is also possible to communicate with a service via intents.
    connector type MessengerConnectorT;

    // Connector for Android services
    connector type ServiceConnectorT;

    // This group type is the way that we define applications.
    group type AndroidApplicationGroupT = {
      // this is the set of permissions that the app uses. It is modeled after the <uses-permission> tag in the
      // app manifest: http://developer.android.com/guide/topics/manifest/uses-permission-element.html
      property usesPermissions : PermissionsSetT;
      rule validMembers = invariant forall m in self.MEMBERS | declaresType (m, ApplicationElement) or declaresType (m, ContentProviderComponentT);
      // Only application elements can be in the group. Do we need the connectors?
      rule validPermissions = invariant forall m :! ApplicationElement in self.MEMBERS | (hasValue(m.permission) -> contains (m.permission, usesPermissions));
      rule validPermission2 = invariant forall m :! ContentProviderComponentT in self.members | (((hasValue(m.write-permission) and m.write-permission != "") -> contains (m.write-permission, usesPermissions) and (hasValue(m.read-permission) and m.read-permission != "") -> contains (m.read-permission, usesPermissions)));
    };

    connector ImplicitIntentBus : IntentBusT;


    rule validComponentReferences = heuristic forall p in /self/COMPONENTS/PORTS:!ExplicitIntentCallPortT | exists c:!ApplicationElement in self.COMPONENTS | c.class == p.componentReference;

    // This rule checks that activities receiving implicit intents have the appropriate filters.
    // This is wrong: connection doesn't imply reception, and so this rule can't be written
    // rule matchImplicitIntentFilter = heuristic forall c1 in self.COMPONENTS, c2 :! IntentFilteringApplicationElementT in self.COMPONENTS |
    //    ((c1 != c2 and connected(c1,c2)) -> forall p1:!ImplicitIntentBroadcastAnnouncerPortT in c1.PORTS, p2:!ImplicitIntentBroadcastReceivePortT in c2.PORTS |
    //            (connected(p1, p2) -> contains(p1.action, c2.intentFilters)));

    rule realMatchImplicitIntentFilter = heuristic forall p1 in /self/COMPONENTS/PORTS:!ImplicitIntentBroadcastAnnouncerPortT |
          exists c :! IntentFilteringApplicationElementT in self.COMPONENTS | exists p2 :! ImplicitIntentBroadcastReceivePortT in c.PORTS |
            (connected(p1,p2) -> contains (p1.action, c.intentFilters));

    // This rule checks that if two application elements are connected, and one of them
    // is internal, then they must be from the same app.
    rule noInternalElementsCommunicateOutside =
      invariant forall g1 :! AndroidApplicationGroupT in self.groups | forall g2 :! AndroidApplicationGroupT in self.GROUPS |
        forall a1 :! IntentFilteringApplicationElementT in g1.MEMBERS |
          forall a2 :! ApplicationElement in g2.MEMBERS |
            ((a1 != a2 and connected(a1, a2) and !a1.exported) -> g1 == g2);

    // If an element has intent filters it should be connected
    // to the intent bus
    rule connectedToIntentBus =
      invariant forall c1 :! IntentFilteringApplicationElementT in self.COMPONENTS |
        size (c1.intentFilters) > 0 -> connected (ImplicitIntentBus, c1);


 }